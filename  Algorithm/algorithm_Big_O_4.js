/* 
    BigO_chapter_4
    BigO 표현식의 단순화 하기
*/

/*
    O(2n) => X , O(n)으로 단순하게 표현 할 수 있다.
    O(500) => X , O(1)아라고 한다 
        why? O(500)은 쉽게 말하면 연산갯수가 어떤 상황이든 500개가 있다는 것 n이 무엇이든 .. 
    O(13n²) => x , O(n²) 이라고 한다. 
*/ 

/*
    1. 산수는 상수 (덧셈,뺄셈,곱셈,나눗셈을 포함) (n의 값 상관 없다 => 컴퓨터가 2+2를 처리하는 시간과 10000000+2를 처리하는 시간은 비슷하다.)
    2. 변수 배정도 상수 (x=1000 를 처리하는 것과 x = 20000을 하든 비슷한 시간이 걸린다)
    3. 인덱스를 사용해서 배열 엘리먼트에 접근하는 것 => 배열에서 첫번째 아이템을 찾던지, 10번째 아이템을 찾던지 인덱스를 사용하면 똑같은 시간이 걸린다.
       아니면 객체를 다루고 데이터를 접근하기 위해서 키가 있다면 그것도 실행시간이 상수 이다.
    4. loop가 있으면 복잡도가 loop의 길이 곱하기 loop 안에 있는 연산이 된다 그렇기 때문에 리스트에 있는 데이터를 loop로 처리할 때 0에서 n까지 간다면,
       n이 커질수록 loop가 반복되는 횟수가 늘어난다. 그렇다면 loop안에서 일어나는 작업들도 중요할 수 있다. 
       만약 중첩 loop가 있다면 n² 실행시간이 될 수 있다. 
*/

function logAtLeast5(n) {
    for (var i = 1; i <= Math.max(5,n); i++) {
        console.log(i);
    }
}
/*
    logAtLeast5(10) => 로그 10번 찍는다.
    logAtLeast5(1) => 로그 5번 찍는다.
    logAtLeast5 함수는 n까지 숫자를 출력하지만 최소한 1~5까지 출력한다.
    logAtLeast5(3) => 로그 5번 찍는다.
    logAtLeast5(7) => 로그 7번 찍는다.

    그렇다면 logAtLeast5 에서 BigO 는?

    loop 가 있다, 결국 5까지 가거나 n까지 반복 할 것 Math.max(5,n)가 신경쓰이지만 해당 부분은 n의 값이 작을 경우에만 중요한 부분
    주목해야 할 부분은 n이 커지고 커지는 경우 => 무한대 까지 그럴때 실행시간은 ? 
    if (n = 1000000) => 해당 loop는 1000000번 반복된다.
    그러므로 O(n) n이 커질수록 연산 객수가 n에 비례해서 늘어나기 때문 
*/

function logAtMost5(n) {
    for (var i = 1; i <= Math.min(5, n); i++) {
        console.log(i);
    }
}

/*
    logAtMost5(30) => 로그 5번
    logAtMost5(3) => 로그 3번 
    
    logAtMost5 함수는 
    5보다 더 큰 숫자를 입력하면 5번만 출력하며 5보다 작은 숫자를 입력시 그 숫자만큼 출력한다.
    양수만 가능 0 입력시 아무것도 하지 않는다.

    중요한 것 n이 커져도 아무 영향을 주지 않는다는 것 
    n이 10000 이여도 loop는 5번만 반복 n이 3이면 3번 n이 아무리 크다 해도 5를 넘지 않을 것이다. 
    그렇기 때문에 BigO는 상수라고 단순화 할 수 있다. 
    O(1)

*/

